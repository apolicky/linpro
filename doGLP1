set Hrany := {(0,1),(0,2),(0,3),(1,2),(2,3),(3,1)};
var x{(i,j) in Hrany}, integer, >= 0;

set Vahy := {(0,1,4),(0,2,3),(0,3,1),(1,2,3),(2,3,2),(3,1,5)};
#set Vahy{(i,j) in Hrany} := {(0,1,4),(0,2,3),(0,3,1),(1,2,3),(2,3,2),(3,1,5)};

hranovy_zakaz{(i,j) in Hrany, (j,k) in Hrany, (k,l) in Hrany: l == i } : x[i,j] + x[j,k] + x[k,l] >= 1;

#p0: x["1 -> 2"] + x["2 -> 3"] + x["3 -> 1"] >= 1;
#p1: x["2 -> 3"] + x["3 -> 1"] + x["1 -> 2"] >= 1;
#p2: x["3 -> 1"] + x["1 -> 2"] + x["2 -> 3"] >= 1;


var vahaOdebranych;

#pVO: vahaOdebranych >= x[0,1]*4 + x[0,2]*3 + x[0,3]*1 + x[1,2]*4 + x[2,3]*2 + x[3,1]*5;

pVO: vahaOdebranych >= sum{(i,j) in Hrany, (k,l,m) in Vahy : i==k && j==l} x[i,j]*m;

minimize obj: vahaOdebranych;
solve;
printf "#OUTPUT: %d\n", vahaOdebranych;
for {(i,j) in Hrany: x[i,j] == 1} { printf "%d -> %d\n", i, j; }
printf "#OUTPUT END\n";
end;
